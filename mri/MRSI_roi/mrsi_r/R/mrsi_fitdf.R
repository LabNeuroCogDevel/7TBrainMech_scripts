#' p-value or t-value
#' returns whichever model supports
#' @param cfs single coefficent row from model summary.
#' @param aslist boolean to return list instead of string
#' @importFrom methods isClass
#' @export
p_or_t <- function(cfs, aslist=F) {
  stopifnot(isClass('numeric',summary(m)$coeff))
  if ("Pr(>|t|)" %in% names(cfs))
     sig <- list(m="p", v=cfs["Pr(>|t|)"])
  else
     sig <- list(m="t", v=cfs["t value"])

  if(aslist) return(sig)

  do.call(paste, c(sep=": ", sig))
}

#' @title what y: age2 invage or age
#' @description returns which age was modeled
#' @param cfs coefficent table from model summary.
#' @importFrom methods isClass
#' @export
what_age_y <- function(cfs) {
  stopifnot(isClass('matrix',summary(m)$coeff))
  bestfit <- case_when( 'age2' %in% row.names(cfs) ~ 'age2',
                        'invage' %in% row.names(cfs) ~ 'invage',
                        TRUE ~ 'age')
}


#' CRLB clean
#' add ages, remove bad crlb
#' @param d dataframe with ld8, region, metabolite, and CRLB columns
#' @param regions numeric regions vector to include
#' @param CRLB quoted column name for thresholding
#' @param nona columns that cannot be NA. default to GMrat, age, and CRLB's .SD -> .Cr
#' @param crlb_thres where to discard SD values (default 20)
#' @param mesg  boolean if we should report how many are kept/removed (default F)
#' @import dplyr
#' @importFrom stats na.omit
#' @examples
#'  glu_r1 <- mrsi_clean(d, 1, 'Glu.SD')
#'  glu_r1 <- mrsi_clean(d, 1, 'Glu.SD', nona=c("GMrat", "Glu.Cr", "age")) # same as above
#'  glu_r1 <- mrsi_clean(d, 1, 'Glu.SD', nona=NULL) # NA okay
#' @export
mrsi_clean <- function(d, regions, CRLB, nona=c("GMrat", "age", gsub(".SD",".Cr",CRLB)), crlb_thres=20, mesg=F) {
  # make nonline age columns if we don't already have them
  if(! 'invage' %in% names(d)) d$invage <- 1/d$age
  if(! 'age2'   %in% names(d)) d$age2   <- d$age^2

  brain_region_all <- d %>% filter(roi %in% regions)

  # remove nas. like na.omit but only for a subset of columns
  if(!is.null(nona)){
    nas <- lapply(nona, function(x) is.na(brain_region_all[,x]))
    anyna <- Reduce(`|`, nas) # combine by or-ing each
  } else {
    anyna <- F
  }

  brain_region <-
    brain_region_all %>%
    filter(!!sym(CRLB) <= crlb_thres, !anyna)


  #MESG: return sample size so i know how many people i now have after exclusions

  if(mesg) cat(sprintf("region(s) %s, %s > %d: retaining %d/%d (%d NA)\n",
              paste(collapse=",", regions),
              CRLB, crlb_thres,
              nrow(brain_region), nrow(brain_region_all),
              length(which(anyna))))

  return(brain_region)
}

#' @title
#' find best MRSI data model fit
#' @description
#' pick lowest AIC model among lin, inv, and quad w/rand effects if more than one region
#' @param d (cleaned) dataframe with ld8, roi+label, metabolite, and CRLB columns
#' @param metabolite quoted column name (x value)
#' @param nuissance formula string for additional regressors. defaults to "GMrat"
#' @importFrom magrittr %>%
#' @importFrom lme4 lmer
#' @importFrom stats AIC as.formula lm predict
#' @export
mrsi_bestmodel <- function(d, metabolite, nuissance="GMrat") {
  require(dplyr)

  # AGE EFFECT
  # Test linear, inverse, and quadratic fits

  # models - 1st %s replaced w/ metabolite
  #        - 2nd %s replaced w/ nuissance (GMrat, maybe label and random eff)
  models_strs <-
      list(age   ="%s ~ age        + %s",
           invage="%s ~ invage     + %s",
           age2  ="%s ~ age + age2 + %s")

  # default to
  # nuisance just GM ratio and using `lm`
  mdlfunc <- lm

  # if we have more than one region, add label and random effect of subject
  # also need to use lmer instead of lm
  regions <- unique(d$roi)
  if (length(regions) > 1) {
     nuissance <- paste0(nuissance, '+ label + (1|ld8)')
     mdlfunc <- lme4::lmer
  }

  # fill in formula and calculate model
  models <- lapply(models_strs, function(fmlstr)
                   sprintf(fmlstr, metabolite, nuissance) %>% as.formula %>% mdlfunc(d))
  AICs <- sapply(models, AIC)

  # find which is the best based on AIC
  bestfit <- names(AICs)[which.min(AICs)] # age, invage, or age2
  best_model <- models[[bestfit]]

  cfs <- summary(best_model)$coefficients[bestfit, ]
  sig = p_or_t(cfs)
  #MESG: return sample size so i know how many people i now have after exclusions
  cat(sprintf("%s region(s) %s: best=%s (AIC%.03f, %s)\n",
              metabolite,paste(regions), bestfit, min(AICs), sig))

 return(best_model)
}


#' @title
#' get estimates from the best model
#' @description
#' returns estimate dataframe for plotting.
#' includes p and beta columns (same value repeated in ea. row)
#' @param m  model generated by [mrsi_bestmodel()]
#' @importFrom emmeans ref_grid
#' @export
mrsi_fitdf <- function(m) {
  # todo: get brain_regions and best fit from model

  # reconstruct what age was used for this model
  cfs <- summary(m)$coefficients
  bestfit <- what_age_y(cfs)

  # need max age
  # get data frame from model (different for lme4 and lm)
  # if not slot, hopefully 'model' exists
  d <- tryCatch(m@frame, error=function(e) m$model)
  # and get age range (different for invage)
  if (bestfit == "invage") ages <- range(1/d$invage)
  else                     ages <- range(d$age)

  # assume first element in RHS of forumal is metabolite
  # should maybe be something passed in to the function?
  mtbl_str <- names(d)[1]
  # what to use as age column to use as input for emmeans
  # age2 needs 2 columns (age + age2)
  interp_age <- seq(ages[1], ages[2], by=.1)

  if (bestfit == "age") {
    best_list <- list(age=interp_age)
  } else if (bestfit=="invage") {
    best_list <- list(invage=1/interp_age)
  } else if (bestfit=="age2") {
    best_list <- list(age=interp_age, age2=interp_age^2)
  } else {
      stop("unknown best AIC model!", bestfit)
  }

  avgs <- emmeans::ref_grid(m, at=best_list)
  fitdf <- as.data.frame(summary(avgs))

  # will want age for plotting. add back if we dont have it (invage fit)
  # N.B. if we mean center inv age, this wont be as easy to revert
  if (bestfit == "invage") fitdf$age <- 1/fitdf$invage

  fitdf$bestfit <- bestfit
  fitdf$metabolite <- mtbl_str
  fitdf$beta <- cfs[bestfit, "Estimate"]
  fitdf$tval <- cfs[bestfit, "t value"]

  return(fitdf)
}
